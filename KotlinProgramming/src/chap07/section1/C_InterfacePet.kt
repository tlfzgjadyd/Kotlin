package chap07.section1

/*< 인터페이스를 사용하는 이유 >
* 클래스는 1개만 상속 가능하기 때문에 여러 기능을 상속할 수 있도록 하기 위해서
*
* < 자바의 default 키워드가 코틀린에는 필요 없는 이유 >
* 자바에서 default 키워드를 함수 정의부 앞에 붙여서 default void function(){} 처럼 쓰는게 있는데
* 이 기능이 자바에 추가된 가장 큰 이유는 여러 클래스가 매번 인터페이스 함수 구현하기 귀찮기 때문이다
* 하지만 코틀린은 이걸 기본으로 제공하므로 default 키워드는 필요하지 않아서 없음
* 
* < 인터페이스 사용법 >
* 1. interface 키워드를 사용해 인터페이스 선언하고
* 2. 이를 상속한 하위 클래스에서는 override를 통해 이를 구현해줘야한다
* 3. interface 인터페이스명 [ : 상속한 인터페이스명 ]{
*       추상프로퍼티 & 추상메소드 선언    -> 추상프로퍼티, 추상메소드는 선언만 해둠
*       [ 일반메소드 선언 {정의} ]      -> 정의까지 함께한 메소드는 일반메소드가 된다
*
* <인터페이스 주의사항 >
* 인터페이스 내부에서 메소드는 추상으로도 일반으로도 선언 가능하지만
* 프로퍼티는 반드시 추상 프로퍼티로만 선언해야함에 주의한다
* 즉 인터페이스 내에서 프로퍼티는 초기화하면 안된다는 것
*
* <인터페이스 내 프로퍼티와 메소드의 차이점 >
* 1. 인터페이스 내 프로퍼티는 초기화해선 안된다 
*    (인터페이스 내 프로퍼티는 일반 안되고 추상으로만 선언해야하기 때문)
* 2. 반면 인터페이스 내 메소드는 정의부를 둬도됨
*    ( 인터페이스 내 메소드는 정의부까지 쓰면 일반메소드가 된다)
* 
* < 상속받는 방식의 차이점 >
* 자바에서는 클래스를 상속받으면 extends, 인터페이스를 상속받으면 implements로 구분되지만
* 코틀린에서는 둘다 : 로 통일한다
*
* < 아니 왜 자꾸 같은파일을 수정하는거임.. >
* 이미 작성해서 필기 해둔 파일의 코드를 수정하겠다는데
* 그 이유는 지금은 개가 들어오면 개랑 놀게 오버로딩, 고양이가 들어오면 고양이랑 놀게 오버로딩 돼있지만
* 만약 동물 종류가 무한정으로 늘어나면 매번 메소드 작성해줘야해서 번거롭다
* 이럴때 인터페이스를 사용해서 해결할 수 있음 놀아주는 메소드 하나로 줄여버릴거다
* 
* Pet 인터페이스 안에다 species 변수를 아예 선언 추가해놓고
* Cat클래스, Dog 클래스에서 각각 변수값을 "cat", "dog"로 초기화
* Master클래스에서는 놀아주는 함수 여러개였던거 하나로 줄여버리고
* Pet자료형으로 이름받아서 놀아주는 함수 하나만 둔다
*
* =>기존에 Master클래스는 Cat, Dog클래스에 의존적이었는데
*   이렇게 하면 인터페이스를 통해 의존성을 제거한 셈이 됨
*   이렇게 Master클래스가 독립성을 확보할 수 있다는 점에서 인터페이스는 핵심 역할을 했다
* */

///////////////////// 1. Pet 인터페이스 ///////////////////////////////////////////////
interface Pet{
    var category: String //abstract 키워드가 없어도 기본은 추상 프로퍼티, 여기서 만약 초기화하려하면 에러남
    val msgTags: String //val 선언 시 인터페이스인데도 getter 구현이 가능해짐
        get() = "I'm your lovely pet!"

    var species: String //종을 위한 프로퍼티
    fun feeding() //마찬가지로 추상 메소드
    fun patting() { //일반 메소드: 구현부를 포함하면 일반적인 메소드로 기본이 됨
        println("Keep patting!")//구현부
    }
}
///////////////////// 2. Pet 인터페이스를 상속받는 Cat 하위클래스 ////////////////////////
class Cat(name: String, override var category: String) : Pet, Animal(name){ //클래스 상속받듯이 인터페이스를 여기에 쓰고나서 구현하면됨
    override var species: String="cat"
    override fun feeding(){                     //이때 자바는 클래스 상속받는지 인터페이스 상속받는지에 따라
        println("Feed the cat a tuna can!")     // extends, implements로 갈리지만 코틀린은 :로 통일이다
    }
}
//////////////////// 3. main함수 //////////////////////////////////////////////////////
//D_CatAndDog 파일 실행하느라 Cat 생성자 구성을 바꿔버려서 아래코드 작동하지 않아서 주석으로 막아둠
/*
fun main() {
    val obj = Cat("small")
    println("Pet Category: ${obj.category}")
    obj.feeding() //구현된 메소드
    obj.patting() //기본 메소드
}
*/