package chap10.section1

/* < 클로저 >
* 클로저 : 람다식 쓰다보면 내부 함수에서 외부 변수를 호출하고 싶을 때가 있음
*         람다식으로 표현된 내부함수에서 외부 변수에 접근 가능할 수 있게 하는 개념
*         람다식 안에서 외부 변수는를 사용할 경우 람다식이 포획한 변수라고 부르게 되는데
*         이 포획한 변수들은 다른 지역변수들과 달리 함수 끝나도 메모리에서 사라지지 않음
*
*         클로저 개념 - 포획한 변수의 경우 참조가 유지되어 함수가 종료되어도 사라지지 않는다
*         따라서 함수의 변수에 접근하거나 수정할 수 있게 해줌
* 
* < 클로저 조건 >
* 1. final 변수를 포획했을 경우 : 변수 값을 람다식과 함께 저장한다
* 2. final이 아닌 변수를 포획했을 경우 : 변수를 특정 래퍼(wrapper)로 감싸서 
*                                   나중에 변경하거나 읽을 수 있도록 한다, 
*                                   이때 래퍼에 대한 참조를 람다식과 함께 저장한다
* => 이 둘은 final을 포획했을 경우와 final 아닌쪽을 포획했을 경우 작동 원리를 알려주는거 아닌가?
*    이게 어떻게 클로저일 조건이 된다는거지했는데 그 저장한다는 부분이 내가 직접 저장해줘야하는거임
*    내가 저장한 이후에야 비로소 클로저일 조건을 충족시켜서 클로저가 되는것
*    예를 들면 아래의 예제에서 result라는 외부변수를 람다식에 사용하는데
*    사용하는 동안 result = x+y로 포획변수의 값을 수정해서 저장하기 때문에 별도로 저장하는 조건을 충족하는게 되는 셈이다
* 
* < 자바에서와 코틀린에서의 차이점 >
* 자바에서는 외부 변수 포획할 때 final만 사용할 수 있는 반면
* 코틀린에서는 final이 아닌 변수를 사용하면 알아서 final로 변환해주기 때문에 상관 없다
* 
* < 클로저 사용의 장점 >
* 1. 람다식에서 외부 함수의 변수에 접근해 처리할 수 있음
* 2. 완전히 다른 함수에서 변수에 접근하는 것을 제한할 수 있음
* 
* */

fun main() {
    val calc = Calc()
    var result = 0 //외부의 변수
    calc.addNum(2, 3) { x, y-> result = x+y} //클로저, 람다식 내부에서 외부 변수인 result를 사용하고 있기에
                                                    //이때의 result는 포획된 변수이며 함수가 끝나도 사라지지 않는다
    //원래였으면 addNum은 Calc의 멤버메소드라 addNum 호출됐을때 result는 자신의 유효범위 벗어나서 삭제돼야하지만
    //클로저 개념에 의해 독립된 복사본을 가진다, 클로저일 조건에서 저장해야한다는 조건이 있었잖아
    //여기서 ->의 오른쪽에 있는 result = x+y가 바로 그부분이다
    //포획한 변수인 result값을 수정해서 저장했기 때문에 클로저일 조건을 충족한것
    println(result)//값을 유지하여 5출력

    //길이가 일치하는 이름만 반환
    fun filteredNames(length: Int) {
        val names = arrayListOf("Kim", "Hong", "Go", "Hwang", "Jeon")
        val filterResult = names.filter{
            it.length ==length //바깥의 length에 접근
        }
        println(filterResult)
    }
    filteredNames(4)
}

class Calc{
    fun addNum(a: Int, b: Int, add: (Int, Int)->Unit){ //람다식 add에는 반환값이 없음
        add(a, b)
    }
}