package chap07.section2

/*코틀린에는 2종류의 내부클래스 기법이 있다
* 1. 중첩 클래스 (Nested)
* 2. 이너 클래스 (Inner)
* + 저 2개가 중심이고 추가로 지역클래스, 익명클래스도 있긴함 밑에서 비교해볼거임
*
* < 클래스 내부에 또 클래스를 두는 이유 >
* 클래스 내부에 또 다른 클래스를 두는 이유는
* 1. 독립적인 클래스로 정의하기 애매하거나
* 2. 다른 클래스에서는 잘 사용하지 않고 이 클래스에서만 쓰는 클래스이기 때문
* => 이거 한참동안 왜쓰는지 몰랐었는데 오늘 최대의 수확이다
* 
* < 내부클래스를 많이 쓸 경우에 주의사항 >
* 내부클래스 너무 많이 쓰면
* 1. 클래스 의존성이 커지고
* 2. 코드 읽기가 어려워짐
*
* < 자바의 내부 클래스 종류 >
* 자바에도 내부클래스가 있는데 여러 종류의 내부클래스가 있다
* 1. 정적 내부클래스 : 인스턴스 안만들고도 바로 사용 가능함 (static)
* 2. 멤버 내부클래스 : 인스턴스 클래스라고도 불리고 외부클래스와 연동하는 클래스다
* 3. 지역 내부클래스 : 특정 블록 내에서만 피룡한 경우
* 4. 익명 내부클래스 : 일회용
*
* < 자바와 코틀린의 내부 클래스 비교 >
* 정적 내부클래스  vs  중첩 클래스(Nested) : 객체 생성 없이 사용 가능
* 멤버 내부클래스  vs  이너 클래스(Inner)  : 필드나 메소드와 연동하는 내부클래스
* 지역 내부클래스  vs  지역 클래스(Local)  : 특정 블록 내에서만 필요한 경우 
* 익명 내부클래스  vs  익명 클래스(Anonymous) : 일회용, object키워드 사용 
* 
* < 자바와 코틀린의 내부 클래스 키워드 차이 비교하기 >
* 1. 자바의 멤버(이너)클래스 : 키워드 없음
*    코틀린의 이너클래스 : inner키워드 사용, 코틀린의 중첩클래스와 달리 외부클래스(겉에감싼클래스) 필드에 접근이 가능하다
* 
* 2. 자바의 정적 클래스 : static키워드 사용
*    코틀린의 중첩클래스 : 키워드 없음, 코틀린에선 아무 키워드 없는 클래스는 중첩클래스로 자바의 정적 클래스처럼 사용된다,
*                       코틀린의 이너클래스와 달리 외부클래스(겉에감싼클래스) 필드나 메소드에 접근할 수 없다
*
* => 이때 자바와 코틀린 각각 키워드 안쓰는 경우가 반대이기 때문에 헷갈리지 않게 주의해야한다
* 
* < 코틀린 이너클래스와 중첩클래스 차이점 >
* 1. 이너클래스는 inner키워드, 중첩클래스는 아무 키워드도 사용하지 않는다
* 2. 이너클래스는 겉에 감싼 외부클래스에 접근 가능하지만 중첩클래스는 겉에 감싼 외부클래스에 접근 불가능하다
* 
* < 코틀린의 중첩클래스 알아보기 >
* 코틀린에서 중첩 클래스는 기본적으로 정적 클래스처럼 다뤄진다
* 즉 별도의 인스턴스 생성 없이 사용이 가능하다는 뜻이다
* */
class Outer{
    val ov = 5
    class Nested{ //여기에 중첩클래스
        val nv = 10
        fun greeting() = "[Nested] Hello ! $nv" //Nested 클래스라서 외부클래스인 Outer의 ov프로퍼티, outside메소드엔 접근 불가
    }
    fun outside() {
        val msg = Nested().greeting() //객체 생성 없이 중첩 클래스의 메소드 접근
        println("[Outer]: $msg, ${Nested().nv}") //중첩 클래스의 프로퍼티 접근
    }
}
fun main() {
    //static처럼 객체 생성 없이 사용
    val output = Outer.Nested().greeting()
    println(output)

    //Outer.outside() //외부 클래스는 인스턴스 생성 없이는 사용 불가능하기에 에러
    val outer = Outer()
    outer.outside()
}