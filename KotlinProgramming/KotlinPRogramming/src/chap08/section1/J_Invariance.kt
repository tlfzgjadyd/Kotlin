package chap08.section1

/* < 제네릭에는 자료형 제한이 필요하다 >
* 제네릭은 모든 자료형을 받을 수 있지만 그렇기에 위험하다
* 예를들면 실제로는 상하관계에 있는 자료형인데 제네릭으로 해버리면 관계 꼬이는 등 문제 생길 수 있음
* 따라서 제네릭에도 추가적으로 in, out, 등의 추가작업을 통해 자료형을 제한해줘야한다
* 
* < 상. 하위 형식의 가변성 >
* 가변성 : 가변성이란 형식 매개변수가 클래스 계층에 영향주는것을 의미한다
*         형식 a의 값이 필요한 모든 클래스에 형식 b의 값을 넣어도 아무 문제가 없다면 b는 a의 하위 형식(subtype)이다
* 
* < 클래스와 자료형 구분하기 >
* String은 클래스지만 String?은 클래스가 아니다
* 하지만 둘 다 자료형이다
* List도 클래스지만 List<String>은 클래스가 아니다
* 하지만 둘 다 자료형이다
* 
* 이 둘을 구분해야하는 이유는 클래스는 상위클래스가 하위클래스를 수용할 수 있다는 특징이 있기 때문이다
* 1. 상위클래스 Number로 하위클래스 Int를 가리킬 수 있다
* 2. null가능 자료형인 Int?로 하위클래스 Int를 가리킬 수 있다
* 3. 하지만 Number?로 Number클래스를 가리킬 순 없다 왜냐면 Number?는 클래스가 아니라 자료형일 뿐이기 때문이다
*
* < 가변성의 3가지 유형 >
* 제네릭에서 상, 하위와 같은 관계를 주기 위해선 가변성의 3가지 특징을 이해하고 있어야한다
* 1. 공변성     : T'가 T의 하위 자료형이면 C<T'>도 C<T>의 하위 자료형이다 ( 생상자 입장의 out 성질, class Box<out T>이런식으로 사용)
* 2. 반공변성   : T'가 T의 하위 자료형이면 C<T>는 C<T'> 하위 자료형이다   ( 소비자 입장의 in 성질, class Box<int T>이런식으로 사용)
* 3. 무변성    : C<T>와 C<T'>는 아무 관계가 없다 (생상자 + 소비자, class Box<T>이런식으로 사용)
*
* < 무변성 invariance >
* 위에서도 볼 수 있듯이 따로 in이나 out등을 지정해주지 않을 경우 무변성으로 제네릭 클래스가 선언된다
* 무변성으로 선언해버리면 Any와 Int가 실제론 상하관계에 있더라도 제네릭에 넣었을땐 상하관계가 안맞게된다
* +이때 Any<-Int<-Nothing 클래스로 실험을 할거다 Nothing은 최하위 클래스인듯
* */

class Invariance<T>(val size: Int)

fun main() {
    //val anys: Invariance<Any> = Invariance<Int>(10) //자료형 불일치로 에러난다
    //val nothings: Invariance<Nothing> = Invariance<Int>(20) //자료형 불일치로 에러난다
}